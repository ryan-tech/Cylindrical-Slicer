//The g-code generated by slic3r seems to mostly use the G1
//command which moves the print head and can either extrude or not.
//This lends itself to a linked list structure for each layer
//and a queue to hold each layer.
//The circular linked list will hold the intersection point coordinates
//and a pointer to the next intersection point coordinate.
//The g-code commands are read by the printer as a queue of commands so each layer,
//layers defined by their z coordinate, will be pushed on the queue.

/*
Purposes of this class
-Store the location of the intersection point
-Generate the g-code command
-Hold a pointer to the next intersection point

*/
#ifndef INTERSECTIONPOINT_H
#define INTERSECTIONPOINT_H

#include "printParameters.h"

class intersetionPoint
{
public:
    intersetionPoint();
    intersetionPoint(float x, float y, float z);
    intersetionPoint(float x, float y, float z, float e, float f, bool extrude);

    float getXVal () {return m_xVal; }
    float getYVal () {return m_yVal; }
    float getZVal () {return m_zVal; }
    float getEVal () {return m_eVal; }
    float getFVal () {return m_fVal; }
    bool getExtrude () {return m_extrude; }
    IntersetionPoint *getNext () {return m_next;}

    void setXVal (float xPoint) { m_xVal = xPoint; }
    void setYVal (float yPoint) { m_yVal = yPoint; }
    void setZVal (float zPoint) { m_zVal = zPoint; }
    void setEVal (float ePoint) { m_eVal = ePoint; }
    void setFVal (float fPoint) { m_fVal = fPoint; }
    void setExtrude (bool extrude) { m_extrude = extrude; }
    void setNext (IntersetionPoint *point) { m_next = point; }

    float calc_e_val();
    float calc_f_vale();

    //isPath() will determine if the current point to the next must be extruded
    //it will set the result to m_extrude
    void isPath();
    void generateGcodeCommand();

private:
    float m_xVal;
    float m_yVal;
    float m_zVal;
    float m_eVal;
    float m_fVal;
    bool m_extrude;
    string m_gcodeCommand;
    IntersetionPoint *m_next;
};

class layer
{
    intersetionPoint *m_start;
public:
    layer(intersetionPoint point);

    //Insert node
    void insert (intersetionPoint *value, int place=-1);

    //Remove node
    void remove(int place);

    //Export g-code
    void exportGCode();
};

#endif
